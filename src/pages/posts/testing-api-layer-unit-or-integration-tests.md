---
title: Testing API Layer. Unit or Integration Tests
date: 2020-05-15T15:15:06.792Z
template: post
---
Applications often are split into layers.

API layer abstracts the communication protocol and allows front-end code to communicate with the back-end using regular function calls.

*api.ts*:
```ts
const getUserInfo = (userId: string) => {
  return fetch(`/users/${userId}`).then(res => res.json())
}
```

Is there any value in testing the API layer by mocking the HTTP requests?

My answer is "probably not that much".

I suppose that testing the API layer using the real Backend gives a lot more information about the system health.

## Testing Options

**Mock the HTTP requests/responses.** In this case we test the logic that we have inside of the API function. Mostly we make sure that we transform the data that we get from the backend into the format usable by our application. In typed languages it is already covered by the types themselves. Main problem being that if the server will change the payload type - our tests won't break, while the application might have runtime errors.
 
Pros:
- Easy to set up
- No need to manage the real `test` server.

Cons:
- Low informativity

**Use the mock implementation of the HTTP server.** This approach is very similar to mocking the HTTP responses. Unless our mock server is somehow synced with the real implementation.

Pros:
- Easier to control than the real server (you don't have to clean up the database)

Cons:
- Needs to be written and supported
- You need to keep it in sync with the real server implementation

**Test using real server.** Set up a *test* server that can be easily reset. Test the API making real requests. Biggest problem will be that the backend will contain state that needs to be set up and clean up properly.

Pros:
- High informativity. If the API is incompatible with the server - the tests fill fail

Cons:
- Expensive. Hard hard to support. You'll need to clean up the server after the test runs
- Need to share the backend code with the frontend team

**Use shared types generated from the server code.** In this case if you keep the types version in sync with the actual running back-end - it should be fine.

**Have a very generic API module that abstracts network communication quirks.** In this case each specific API module extends the generic API module that abstracts the network and resource access errors. For example lack of authentication.

## Bottom Line

Using the types generated by backend and making sure that they are in sync with the current version of backend should be enough.

In cases where we cant get the type information from the backend it is probably better to have the integration tests in place.